<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS180 Portfolio - Project 2</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        h1, h2 {
            color: #333;
        }
        img {
            max-width: 100%;
            height: auto;
            margin-bottom: 10px;
        }
        .image-container {
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <h1>CS180 Fun with Filters and Frequencies! </h1>

    <h2>Overview</h2>

    <h2>1.1 Finite Difference Operator</h2>
    
    <p>In this part of the project, I used finite difference operators to compute the partial derivatives of the "cameraman" image (shown below) in the x and y directions.</p>
    <div class="image-container">
        <h3>Original Cameraman</h3>
        <img src="media/Original Image.png" alt="Cameraman">
    </div>
    
    <p>These derivatives help understand how pixel values change along these axes, which is critical for edge detection.</p>

     <div class="image-container">
        <h3>Ix</h3>
        <p>Applying the finite difference operator [-1, 1] along the x axis allows us to compute the derivative in x to highlight vertical edges.</p>
        <img src="media/Ix (Derivative in x).png" alt="Ix Cameraman">
    </div>

     <div class="image-container">
        <h3>Iy</h3>
        <p>Similarly, I applied the finite difference operator along the y axis to compute the derivative in y to highlight horizontal edges.</p>
        <img src="media/Iy (Derivative in y).png" alt="Iy Cameraman">
    </div>

    <div class="image-container">
        <h3>Gradient Magnitude</h3>
        <p>Next, I calculated the gradient magnitude, which combines the x and y derivatives to detect the overall strength of edges in the image.</p>
        <p>More specifically, I used this line of code to calculate the gradient magnitude: """ gradient_magnitude = np.sqrt(Ix**2 + Iy**2) """</p>
        <img src="media/Gradient Magnitude.png" alt="Gradient Magnitude">
    </div>

    <div class="image-container">
        <h3>Binarized Magnitude</h3>
        <p>Finally, I found an optimal threshold value based on trial and error to create a binary image that highlights the prominent edges in the image while suppressing noise.</p>
        <img src="media/Binarized Magnitude.png" alt="Binarized Magnitude">
    </div>
    

    <h2>1.2 Derivative of Gaussian (DoG) Filter</h2>

    <p>In this part of the project, I incorporated a Gaussian filter to improve upon the simple finite difference operator. While the finite difference method is effective at detecting edges, it also may produce a lot of noise. A Gaussian filter helps smooth the image before applying derivative operations.</p>
    
    <div class="image-container">
        <h3>Gaussian Filter Applied</h3>
        <p>First, I applied a Gaussian filter to the original image, which blurs the image. This also reduces noise and makes the edges more distinct. I achieved this sign the gaussian_filter() function.</p>
        <img src="media/Blurred Image.png" alt="Gaussian Applied">
    </div>

    <div class="image-container">
        <h3>Ix and Iy derivatives of the Smoothed Image</h3>
        <p>I then computed the x and y derivatives (Ix and Iy) on the smoothed image by convolving it with the finite difference operators (Dx and Dy). This gives us smoother gradients compared to the unblurred image.</p>
        <h3>Ix Blurred</h3>
        <img src="media/Ix (Blurred).png" alt="Blurred derivative of x">
        <h3>Iy Blurred</h3>
        <img src="media/Iy (Blurred).png" alt="Blurred derivative of y">
        <h3>Gradient Magnitude Double Convolved</h3>
        <img src="media/Gradient Magnitude 2.png" alt="Gradient Magnitude Double Convolution">
        <h3>Binarized Magnitude Double Convolved</h3>
        <img src="media/Binarized Magnitude 2.png" alt="Binarized Magnitude Double Convolution">
    </div>
    
    <div class="image-container">
        <h3>Gaussian Filters</h3>
        <p>Instead of applying Gaussian smoothing followed by the derivative separately, we can combine both operations into a single convolution. We can do this by computing the Derivative of Gaussian filters.</p>
        <h3>DoGx Filter</h3>
        <img src="media/DoGx Filter.png" alt="DoGx Filter">
        <h3>DoGy Filter</h3>
        <img src="media/DoGy Filter.png" alt="DoGy Filter">
    </div>

    <div class="image-container">
        <h3>DoG Results</h3>
        <p>I convolved the Gaussian filter with the finite difference operators (Dx and Dy) to produce DoG filters. These filters are then directly applied to the image to compute the x and y derivatives in one single step.</p>
        <h3>Ix DoG</h3>
        <img src="media/Ix (DoG).png" alt="Ix DoG">
        <h3>Iy DoG</h3>
        <img src="media/Iy (DoG).png" alt="Iy DoG">
        <h3>Gradient Magnitude DoG</h3>
        <img src="media/Gradient Magnitude (DoG).png" alt="Gradient Magnitude DoG">
        <h3>Binarized Magnitude DoG</h3>
        <img src="media/Binarized Magnitude (DoG).png" alt="Binarized Magnitude DoG">
    </div>

    <h2>2.1 Fun with Frequencies</h2>

    <p>In this part of the project, I implemented unsharp masking, which enhances the sharpness of an image by emphasizing its high-frequency components.</p>
    <p>This process has three steps: </p>
    <p>1. Gaussian Blur: First, apply a Gaussian blur, which acts as a low-pass filter that removes the high-frequency details, which are typically associated with sharp edges.</p>
    <p>2. Extracting High Frequencies: Next, I subtract the blurred version of the image from the original image, which essentially isolates the high-frequency components.</p>
    <p>3. Enhancing the Sharpness: I then added the high-frequency components back to the original image, with an adjustable weight (alpha) that controls how much the image is sharpened. This result appears sharper because the high-frequency details are emphasized.</p>

    <p>The unsharp mask filter can be mathematically represented as:</p>
    <p>Sharpened image = Original Image + alpha * (Original image - Blurred image)</p>

    <p>The following images illustrate the process mentioned above:</p>
    
    <div class="image-container">
        <h3>Original Taj Mahal</h3>
        <img src="media/Original Taj.png" alt="Original Taj">
        <h3>Sharpened Taj Mahal</h3>
        <img src="media/Sharpened Taj.png" alt="Sharpened Taj">
    </div>

    <div class="image-container">
        <h3>Original Abbey Road</h3>
        <img src="media/Original Abbey Road.png" alt="Original Abbey Road">
        <h3>Sharpened Abbey Road</h3>
        <img src="media/Sharpened Abbey Road.png" alt="Sharpened Abbey Road">
    </div>

    <div class="image-container">
        <h3>Original Free Speech</h3>
        <img src="media/Original Free Speech.png" alt="Original Free Speech">
        <h3>Sharpened Abbey Road</h3>
        <img src="media/Sharpened Free Speech.png" alt="Sharpened Free Speech">
    </div>

    <p>I also tested a scenario in which a sharp image is intentionally blurred, and then sharpened again. By comparing the original sharpened image and the sharpened version of the blurred image, we can see how much of the original detail was restored through the unsharp masking process.</p>

    <div class="image-container">
        <h3>Original MLK</h3>
        <img src="media/Original Sharp Image (MLK).png" alt="Original MLK">
        <h3>Blurred MLK</h3>
        <img src="media/Blurred MLK.png" alt="Blurred MLK">
        <h3>Sharpened MLK</h3>
        <img src="media/Sharpened Blurred Image.png" alt="Re-sharpened MLK">
    </div>

    

        
</body>
</html>
