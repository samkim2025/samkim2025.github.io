<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS180 Portfolio - Project 2</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        h1, h2 {
            color: #333;
        }
        img {
            max-width: 100%;
            height: auto;
            margin-bottom: 10px;
        }
        .image-container {
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <h1>CS180 Fun with Filters and Frequencies! </h1>

    <h2>Overview</h2>

    <h2>1.1 Finite Difference Operator</h2>
    
    <p>In this part of the project, I used finite difference operators to compute the partial derivatives of the "cameraman" image (shown below) in the x and y directions.</p>
    <div class="image-container">
        <h3>Original Cameraman</h3>
        <img src="media/Original Image.png" alt="Cameraman">
    </div>
    
    <p>These derivatives help understand how pixel values change along these axes, which is critical for edge detection.</p>

     <div class="image-container">
        <h3>Ix</h3>
        <p>Applying the finite difference operator [-1, 1] along the x axis allows us to compute the derivative in x to highlight vertical edges.</p>
        <img src="media/Ix (Derivative in x).png" alt="Ix Cameraman">
    </div>

     <div class="image-container">
        <h3>Iy</h3>
        <p>Similarly, I applied the finite difference operator along the y axis to compute the derivative in y to highlight horizontal edges.</p>
        <img src="media/Iy (Derivative in y).png" alt="Iy Cameraman">
    </div>

    <div class="image-container">
        <h3>Gradient Magnitude</h3>
        <p>Next, I calculated the gradient magnitude, which combines the x and y derivatives to detect the overall strength of edges in the image.</p>
        <p>More specifically, I used this line of code to calculate the gradient magnitude: """ gradient_magnitude = np.sqrt(Ix**2 + Iy**2) """</p>
        <img src="media/Gradient Magnitude.png" alt="Gradient Magnitude">
    </div>

    <div class="image-container">
        <h3>Binarized Magnitude</h3>
        <p>Finally, I found an optimal threshold value based on trial and error to create a binary image that highlights the prominent edges in the image while suppressing noise.</p>
        <img src="media/Binarized Magnitude.png" alt="Binarized Magnitude">
    </div>
    

    <h2>1.2 Derivative of Gaussian (DoG) Filter</h2>

    <p>In this part of the project, I incorporated a Gaussian filter to improve upon the simple finite difference operator. While the finite difference method is effective at detecting edges, it also may produce a lot of noise. A Gaussian filter helps smooth the image before applying derivative operations.</p>
    
    <div class="image-container">
        <h3>Gaussian Filter Applied</h3>
        <p>First, I applied a Gaussian filter to the original image, which blurs the image. This also reduces noise and makes the edges more distinct. I achieved this sign the gaussian_filter() function.</p>
        <img src="media/Blurred Image.png" alt="Gaussian Applied">
    </div>

    <div class="image-container">
        <h3>Ix and Iy derivatives of the Smoothed Image</h3>
        <p>I then computed the x and y derivatives (Ix and Iy) on the smoothed image by convolving it with the finite difference operators (Dx and Dy). This gives us smoother gradients compared to the unblurred image.</p>
        <h3>Ix Blurred</h3>
        <img src="media/Ix (Blurred).png" alt="Blurred derivative of x">
        <h3>Iy Blurred</h3>
        <img src="media/Iy (Blurred).png" alt="Blurred derivative of y">
        <h3>Gradient Magnitude Double Convolved</h3>
        <img src="media/Gradient Magnitude 2.png" alt="Gradient Magnitude Double Convolution">
        <h3>Binarized Magnitude Double Convolved</h3>
        <img src="media/Binarized Magnitude 2.png" alt="Binarized Magnitude Double Convolution">
    </div>
    
    <div class="image-container">
        <h3>Gaussian Filters</h3>
        <p>Instead of applying Gaussian smoothing followed by the derivative separately, we can combine both operations into a single convolution. We can do this by computing the Derivative of Gaussian filters.</p>
        <h3>DoGx Filter</h3>
        <img src="media/DoGx Filter.png" alt="DoGx Filter">
        <h3>DoGy Filter</h3>
        <img src="media/DoGy Filter.png" alt="DoGy Filter">
    </div>

    <div class="image-container">
        <h3>DoG Results</h3>
        <p>I convolved the Gaussian filter with the finite difference operators (Dx and Dy) to produce DoG filters. These filters are then directly applied to the image to compute the x and y derivatives in one single step.</p>
        <h3>Ix DoG</h3>
        <img src="media/Ix (DoG).png" alt="Ix DoG">
        <h3>Iy DoG</h3>
        <img src="media/Iy (DoG).png" alt="Iy DoG">
        <h3>Gradient Magnitude DoG</h3>
        <img src="media/Gradient Magnitude (DoG).png" alt="Gradient Magnitude DoG">
        <h3>Binarized Magnitude DoG</h3>
        <img src="media/Binarized Magnitude (DoG).png" alt="Binarized Magnitude DoG">
    </div>

    <h2>1.2 Derivative of Gaussian (DoG) Filter</h2>
    

    
    <p>I initially divided the image into three, each representing the blue, green, and red channels respectively (from top to bottom).</p>
    <p>After dividing them, I sought to align them and produce a color photograph.</p>

    <h2>My Approach</h2>
    <p>First, I tried to see what would happen if I just divided the image in thirds, and stack them on top of each other.</p>
    <p>The result is depicted below, and it's not pretty.</p>
    
    <div class="image-container">
        <h3>Simple Stack Cathedral</h3>
        <img src="media/simple_stacked_cathedral.jpg" alt="Simple Stack Cathedral">
    </div>

    <p>Seeing that approach fail, I sought a different approach. </p>
    <p>First, I used the circular_shift function to align the channels. This method shifts an image by a given offset along the vertical and horizontal axes, and enables us to test different alignments.</p>
    <p>To measure the alignment quality quantitatively, I used the compute_ssd function to calculate sum of squared differences between the reference channel and the shifted target channel. Lower SSD values imply better alignment. </p>
    <p>Then, I use the align_channels method to carry out a brute-fore search over a given range of shifts performed on the target channel. For every shift in this range, I calculate the SSD, and eventually choose the shift with the lowest SSD value. </p>
    <p>For large images (i.e. the .tif files), a brute force becomes super expensive and would take a long time to run. To address this, I implemented the pyramid_align method. In this method, we create an image pyramid that is made up of progressively smaller images, each downsampled from the previous one by a factor of 2. The pyramid method aligns the images at the smallest scale, where the search space is minimal. I then refine this shift at higher resolutions by upscaling the shift.</p>
    <p>To build this image pyramid manually, I've written the manual_downsample and manual_upsample methods, which decreases/increases the image size. </p>
    <p>Finally, the proess_image method carries out this entire process. It reads the image, divides it into three channels, and crops each channel to remove edges (default factor of 5%). The green and red channels are aligned to the blue channel using the pyramid alignment method. Finally, I stack these aligned channels to form the output image, which is saved and displayed.</p>
    
    <h2>Results</h2>
    <p>Below are the results of my algorithm on the provided example images, along with the calculated offsets for each channel:</p>

    <div class="image-container">
        <h3>Cathedral</h3>
        <img src="media/output_cathedral.jpg" alt="Aligned Cathedral">
        <p>Green channel shift: (5, 2)<br>Red channel shift: (12, 3)</p>
    </div>

    <div class="image-container">
        <h3>Monastery</h3>
        <img src="media/output_monastery.jpg" alt="Aligned Monastery">
        <p>Green channel shift: (-3, 2)<br>Red channel shift: (3, 2)</p>
    </div>

    <div class="image-container">
        <h3>Tobolsk</h3>
        <img src="media/output_tobolsk.jpg" alt="Aligned Tobolsk">
        <p>Green channel shift: (3, 3)<br>Red channel shift: (6, 3)</p>
    </div>

    <div class="image-container">
        <h3>Church</h3>
        <img src="media/output_church.jpg" alt="Aligned Church">
        <p>Green channel shift: (25, 4)<br>Red channel shift: (58, -4)</p>
    </div>

    <div class="image-container">
        <h3>Icon</h3>
        <img src="media/output_icon.jpg" alt="Aligned Icon">
        <p>Green channel shift: (41, 17)<br>Red channel shift: (89, 23)</p>
    </div>

     <div class="image-container">
        <h3>Harvesters</h3>
        <img src="media/output_harvesters.jpg" alt="Aligned Harvesters">
        <p>Green channel shift: (59, 16)<br>Red channel shift: (124, 13)</p>
    </div>

    <div class="image-container">
        <h3>Lady</h3>
        <img src="media/output_lady.jpg" alt="Aligned Lady">
        <p>Green channel shift: (51, 9)<br>Red channel shift: (111, 12)</p>
    </div>
    
    <div class="image-container">
        <h3>Melons</h3>
        <img src="media/output_melons.jpg" alt="Aligned Melons">
        <p>Green channel shift: (81, 10)<br>Red channel shift: (178, 13)</p>
    </div>

    <div class="image-container">
        <h3>Onion Church</h3>
        <img src="media/output_onion_church.jpg" alt="Aligned Onion Church">
        <p>Green channel shift: (51, 26)<br>Red channel shift: (108, 36)</p>
    </div>

     <div class="image-container">
        <h3>Sculpture</h3>
        <img src="media/output_sculpture.jpg" alt="Aligned Sculpture">
        <p>Green channel shift: (33, -11)<br>Red channel shift: (140, -27)</p>
    </div>

    <div class="image-container">
        <h3>Self Portrait</h3>
        <img src="media/output_self_portrait.jpg" alt="Aligned Self Portrait">
        <p>Green channel shift: (78, 29)<br>Red channel shift: (176, 37)</p>
    </div>

     <div class="image-container">
        <h3>Three Generations</h3>
        <img src="media/output_three_generations.jpg" alt="Aligned Three Generations">
        <p>Green channel shift: (53, 14)<br>Red channel shift: (112, 11)</p>
    </div>

    <div class="image-container">
        <h3>Train</h3>
        <img src="media/output_train.jpg" alt="Aligned Train">
        <p>Green channel shift: (42, 5)<br>Red channel shift: (87, 32)</p>
    </div>
    
    <div class="image-container">
        <h3>Emir (Failed Alignment)</h3>
        <img src="media/output_emir_bad.jpg" alt="Aligned Emir">
        <p>Green channel shift: (49, 24)<br>Red channel shift: (93, -305)</p>
        <p>Unlike the other images, it was difficult to align the Emirs. This was because there were significant brightness differences across the channels. </p>
    </div>

    <div class="image-container">
        <h3>Emir (original)</h3>
        <img src="media/emir2.jpg" alt="Unaligned Emir">
        <p>As you can see here, the darkness/brightness of the Emir's cloak varies greatly across the channels. In the top-most chanel, the Emir's cloak is very bright (white). In the bottom-most channel, the cloak is very dark (almost black). This difference made it difficult to apply the algorithm nicely. </p>
    </div>

    <h2>Other Images</h2>
    <p>Here are some other images from the collection that I applied my algorithm to:</p>

    <div class="image-container">
        <h3>Castle</h3>
        <img src="media/output_castle.jpg" alt="Aligned Castle">
        <p>Green channel shift: (25, 11)<br>Red channel shift: (90, 26)</p>
    </div>
    
    <div class="image-container">
        <h3>Cross</h3>
        <img src="media/output_cross.jpg" alt="Aligned Cross">
        <p>Green channel shift: (67, -7)<br>Red channel shift: (142, -19)</p>
    </div>

    <div class="image-container">
        <h3>Railroad</h3>
        <img src="media/output_railroad.jpg" alt="Aligned Railroad">
        <p>Green channel shift: (44, 12)<br>Red channel shift: (96, 15)</p>
    </div>
        
</body>
</html>
