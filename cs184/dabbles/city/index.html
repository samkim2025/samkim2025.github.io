<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D City Scene</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
        }
        #time-control {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #time-slider {
            width: 200px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>3D City Explorer</h3>
        <p>Controls:</p>
        <p>- Mouse: Left click + drag to rotate</p>
        <p>- Mouse wheel: Zoom in/out</p>
        <p>- Right click + drag: Pan</p>
    </div>
    <div id="time-control">
        <label for="time-slider">Time of Day:</label>
        <input type="range" id="time-slider" min="0" max="24" value="12" step="0.1">
        <span id="time-display">12:00</span>
    </div>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Camera controls
        camera.position.set(200, 200, 200);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI / 2 - 0.1;
        controls.target.set(0, 0, 0);

        // City parameters
        const CITY_SIZE = 500;
        const BLOCK_SIZE = 50;
        const STREET_WIDTH = 20;
        const NUM_BLOCKS = Math.floor(CITY_SIZE / (BLOCK_SIZE + STREET_WIDTH));
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);
        
        const sunLight = new THREE.DirectionalLight(0xffffff, 2);
        sunLight.position.set(1, 1, 1);
        sunLight.castShadow = true;
        sunLight.shadow.camera.near = 10;
        sunLight.shadow.camera.far = 1000;
        sunLight.shadow.camera.left = -500;
        sunLight.shadow.camera.right = 500;
        sunLight.shadow.camera.top = 500;
        sunLight.shadow.camera.bottom = -500;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        const moonLight = new THREE.DirectionalLight(0x8080ff, 0.5);
        moonLight.position.set(-1, 1, -1);
        scene.add(moonLight);

        // Sky
        const skyGeometry = new THREE.SphereGeometry(5000, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({
            side: THREE.BackSide,
            color: 0x87CEEB
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(CITY_SIZE * 1.5, CITY_SIZE * 1.5);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.8,
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Building creation function
        function createBuilding(width, height, depth, x, z, type = 'skyscraper') {
            const group = new THREE.Group();
            
            // Main building
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            
            let buildingMaterial;
            if (type === 'skyscraper') {
                buildingMaterial = new THREE.MeshStandardMaterial({
                    color: Math.random() > 0.5 ? 0x8899AA : 0x7788AA,
                    roughness: 0.2,
                    metalness: 0.8,
                });
            } else if (type === 'apartment') {
                buildingMaterial = new THREE.MeshStandardMaterial({
                    color: Math.random() > 0.5 ? 0xCC8866 : 0xDDAAAA,
                    roughness: 0.7,
                    metalness: 0.2,
                });
            } else { // shop
                buildingMaterial = new THREE.MeshStandardMaterial({
                    color: Math.random() > 0.5 ? 0xAAAA88 : 0xDDDDAA,
                    roughness: 0.5,
                    metalness: 0.3,
                });
            }
            
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.y = height / 2;
            building.castShadow = true;
            building.receiveShadow = true;
            group.add(building);
            
            // Add windows
            if (type === 'skyscraper') {
                const numFloors = Math.floor(height / 4);
                const numColumns = Math.floor(width / 4);
                const numRows = Math.floor(depth / 4);
                
                const windowGeometry = new THREE.PlaneGeometry(2, 2);
                
                // Windows on front and back
                for (let floor = 0; floor < numFloors; floor++) {
                    for (let col = 0; col < numColumns; col++) {
                        const windowMaterial = new THREE.MeshStandardMaterial({
                            color: 0xFFFFFF,
                            emissive: 0x555555,
                            roughness: 0.5,
                            transparent: true,
                            opacity: 0.7,
                        });
                        
                        // Front windows
                        const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                        frontWindow.position.set(
                            col * 4 - width / 2 + 2,
                            floor * 4 + 2,
                            depth / 2 + 0.1
                        );
                        group.add(frontWindow);
                        
                        // Back windows
                        const backWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                        backWindow.position.set(
                            col * 4 - width / 2 + 2,
                            floor * 4 + 2,
                            -depth / 2 - 0.1
                        );
                        backWindow.rotation.y = Math.PI;
                        group.add(backWindow);
                    }
                }
                
                // Windows on sides
                for (let floor = 0; floor < numFloors; floor++) {
                    for (let row = 0; row < numRows; row++) {
                        const windowMaterial = new THREE.MeshStandardMaterial({
                            color: 0xFFFFFF,
                            emissive: 0x555555,
                            roughness: 0.5,
                            transparent: true,
                            opacity: 0.7,
                        });
                        
                        // Left windows
                        const leftWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                        leftWindow.position.set(
                            -width / 2 - 0.1,
                            floor * 4 + 2,
                            row * 4 - depth / 2 + 2
                        );
                        leftWindow.rotation.y = -Math.PI / 2;
                        group.add(leftWindow);
                        
                        // Right windows
                        const rightWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                        rightWindow.position.set(
                            width / 2 + 0.1,
                            floor * 4 + 2,
                            row * 4 - depth / 2 + 2
                        );
                        rightWindow.rotation.y = Math.PI / 2;
                        group.add(rightWindow);
                    }
                }
                
                // Roof features for skyscrapers
                if (Math.random() > 0.7) {
                    const antennaGeometry = new THREE.CylinderGeometry(0.5, 0.5, height * 0.2, 8);
                    const antennaMaterial = new THREE.MeshStandardMaterial({
                        color: 0x888888,
                        roughness: 0.4,
                        metalness: 0.8,
                    });
                    const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                    antenna.position.y = height + height * 0.1;
                    antenna.castShadow = true;
                    group.add(antenna);
                }
            } else if (type === 'apartment') {
                // Apartment windows and balconies
                const numFloors = Math.floor(height / 3);
                const numColumns = Math.floor(width / 5);
                
                const windowGeometry = new THREE.PlaneGeometry(3, 2);
                const balconyGeometry = new THREE.BoxGeometry(3.5, 0.5, 1.5);
                const balconyMaterial = new THREE.MeshStandardMaterial({
                    color: 0x999999,
                    roughness: 0.7,
                });
                
                for (let floor = 0; floor < numFloors; floor++) {
                    for (let col = 0; col < numColumns; col++) {
                        const windowMaterial = new THREE.MeshStandardMaterial({
                            color: 0xDDDDEE,
                            roughness: 0.5,
                            transparent: true,
                            opacity: 0.7,
                        });
                        
                        // Front windows and balconies
                        const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                        frontWindow.position.set(
                            col * 5 - width / 2 + 2.5,
                            floor * 3 + 1.5,
                            depth / 2 + 0.1
                        );
                        group.add(frontWindow);
                        
                        if (Math.random() > 0.3) {
                            const balcony = new THREE.Mesh(balconyGeometry, balconyMaterial);
                            balcony.position.set(
                                col * 5 - width / 2 + 2.5,
                                floor * 3 + 0.25,
                                depth / 2 + 1
                            );
                            balcony.castShadow = true;
                            balcony.receiveShadow = true;
                            group.add(balcony);
                        }
                        
                        // Back windows
                        const backWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                        backWindow.position.set(
                            col * 5 - width / 2 + 2.5,
                            floor * 3 + 1.5,
                            -depth / 2 - 0.1
                        );
                        backWindow.rotation.y = Math.PI;
                        group.add(backWindow);
                    }
                }
            } else { // shop
                // Storefront
                const doorGeometry = new THREE.PlaneGeometry(4, 7);
                const doorMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.5,
                });
                
                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.set(0, 3.5, depth / 2 + 0.1);
                group.add(door);
                
                // Shop windows
                const shopWindowGeometry = new THREE.PlaneGeometry(width * 0.6, 5);
                const shopWindowMaterial = new THREE.MeshStandardMaterial({
                    color: 0xDDDDFF,
                    transparent: true,
                    opacity: 0.7,
                });
                
                const leftWindow = new THREE.Mesh(shopWindowGeometry, shopWindowMaterial);
                leftWindow.position.set(-width / 4, 4, depth / 2 + 0.1);
                group.add(leftWindow);
                
                const rightWindow = new THREE.Mesh(shopWindowGeometry, shopWindowMaterial);
                rightWindow.position.set(width / 4, 4, depth / 2 + 0.1);
                group.add(rightWindow);
                
                // Shop sign
                const signGeometry = new THREE.BoxGeometry(width * 0.8, 2, 1);
                const signMaterial = new THREE.MeshStandardMaterial({
                    color: Math.random() > 0.5 ? 0xFF5555 : 0x55AAFF,
                    roughness: 0.4,
                    emissive: Math.random() > 0.5 ? 0x882222 : 0x224488,
                    emissiveIntensity: 0.5,
                });
                
                const sign = new THREE.Mesh(signGeometry, signMaterial);
                sign.position.set(0, height * 0.8, depth / 2 + 1);
                sign.castShadow = true;
                group.add(sign);
            }
            
            group.position.set(x, 0, z);
            return group;
        }

        // Street elements
        function createLampPost(x, z) {
            const group = new THREE.Group();
            
            // Pole
            const poleGeometry = new THREE.CylinderGeometry(0.5, 0.6, 12, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.7,
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 6;
            pole.castShadow = true;
            group.add(pole);
            
            // Lamp
            const lampGeometry = new THREE.SphereGeometry(1, 16, 16);
            const lampMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFF88,
                emissive: 0xFFFF00,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.8,
            });
            const lamp = new THREE.Mesh(lampGeometry, lampMaterial);
            lamp.position.y = 12;
            group.add(lamp);
            
            // Light
            const light = new THREE.PointLight(0xFFFF88, 1, 20);
            light.position.set(0, 12, 0);
            light.castShadow = true;
            light.shadow.mapSize.width = 512;
            light.shadow.mapSize.height = 512;
            group.add(light);
            
            group.position.set(x, 0, z);
            return group;
        }

        function createBench(x, z, rotation = 0) {
            const group = new THREE.Group();
            
            // Bench seat
            const seatGeometry = new THREE.BoxGeometry(4, 0.4, 1.5);
            const seatMaterial = new THREE.MeshStandardMaterial({
                color: 0x885522,
                roughness: 0.9,
            });
            const seat = new THREE.Mesh(seatGeometry, seatMaterial);
            seat.position.y = 1;
            seat.castShadow = true;
            seat.receiveShadow = true;
            group.add(seat);
            
            // Bench legs
            for (let i = -1; i <= 1; i += 2) {
                const legGeometry = new THREE.BoxGeometry(0.2, 1, 1.5);
                const legMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.7,
                });
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(i * 1.5, 0.5, 0);
                leg.castShadow = true;
                leg.receiveShadow = true;
                group.add(leg);
            }
            
            // Bench back
            const backGeometry = new THREE.BoxGeometry(4, 1.5, 0.3);
            const backMaterial = new THREE.MeshStandardMaterial({
                color: 0x885522,
                roughness: 0.9,
            });
            const back = new THREE.Mesh(backGeometry, backMaterial);
            back.position.set(0, 1.75, -0.6);
            back.castShadow = true;
            back.receiveShadow = true;
            group.add(back);
            
            group.position.set(x, 0, z);
            group.rotation.y = rotation;
            return group;
        }

        function createTree(x, z) {
            const group = new THREE.Group();
            
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 1, 6, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9,
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 3;
            trunk.castShadow = true;
            group.add(trunk);
            
            // Foliage
            const foliageGeometry = new THREE.SphereGeometry(4, 16, 16);
            const foliageMaterial = new THREE.MeshStandardMaterial({
                color: Math.random() > 0.3 ? 0x228B22 : 0x006400,
                roughness: 0.8,
            });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 8;
            foliage.castShadow = true;
            group.add(foliage);
            
            group.position.set(x, 0, z);
            return group;
        }

        function createTrafficLight(x, z, rotation = 0) {
            const group = new THREE.Group();
            
            // Pole
            const poleGeometry = new THREE.CylinderGeometry(0.3, 0.4, 8, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.7,
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 4;
            pole.castShadow = true;
            group.add(pole);
            
            // Traffic light housing
            const housingGeometry = new THREE.BoxGeometry(1.2, 3, 1);
            const housingMaterial = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.6,
            });
            const housing = new THREE.Mesh(housingGeometry, housingMaterial);
            housing.position.y = 7.5;
            housing.castShadow = true;
            group.add(housing);
            
            // Traffic light lenses
            const colors = [0xFF0000, 0xFFFF00, 0x00FF00];
            for (let i = 0; i < 3; i++) {
                const lensGeometry = new THREE.CircleGeometry(0.3, 16);
                const lensMaterial = new THREE.MeshStandardMaterial({
                    color: colors[i],
                    emissive: colors[i],
                    emissiveIntensity: i === 0 ? 1 : 0.1, // Red light is on by default
                });
                const lens = new THREE.Mesh(lensGeometry, lensMaterial);
                lens.position.set(0, 8.5 - i, 0.51);
                lens.rotation.x = Math.PI / 2;
                group.add(lens);
            }
            
            group.position.set(x, 0, z);
            group.rotation.y = rotation;
            return group;
        }

        function createPedestrian() {
            const group = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: Math.random() > 0.5 ? 0x0077BB : 0x993366,
                roughness: 0.7,
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.2;
            body.castShadow = true;
            group.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFD6A5,
                roughness: 0.7,
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2;
            head.castShadow = true;
            group.add(head);
            
            // Legs
            for (let i = -1; i <= 1; i += 2) {
                const legGeometry = new THREE.CylinderGeometry(0.12, 0.12, 1.2, 8);
                const legMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.7,
                });
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(i * 0.2, 0.6, 0);
                leg.castShadow = true;
                group.add(leg);
            }
            
            // Arms
            for (let i = -1; i <= 1; i += 2) {
                const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
                const armMaterial = new THREE.MeshStandardMaterial({
                    color: bodyMaterial.color,
                    roughness: 0.7,
                });
                const arm = new THREE.Mesh(armGeometry, armMaterial);
                arm.position.set(i * 0.4, 1.4, 0);
                arm.rotation.z = i * Math.PI / 8;
                arm.castShadow = true;
                group.add(arm);
            }
            
            return group;
        }

        function createCar() {
            const group = new THREE.Group();
            
            // Car body
            const bodyColor = new THREE.Color(Math.random() * 0xFFFFFF);
            const bodyGeometry = new THREE.BoxGeometry(4, 1, 2);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: bodyColor,
                roughness: 0.2,
                metalness: 0.8,
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.8;
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);
            
            // Car roof
            const roofGeometry = new THREE.BoxGeometry(2.5, 0.8, 1.8);
            const roofMaterial = new THREE.MeshStandardMaterial({
                color: bodyColor,
                roughness: 0.2,
                metalness: 0.8,
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(-0.3, 1.7, 0);
            roof.castShadow = true;
            roof.receiveShadow = true;
            group.add(roof);
            
            // Wheels
            for (let x = -1; x <= 1; x += 2) {
                for (let z = -1; z <= 1; z += 2) {
                    const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
                    const wheelMaterial = new THREE.MeshStandardMaterial({
                        color: 0x111111,
                        roughness: 0.8,
                    });
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.position.set(x * 1.3, 0.4, z * 1);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.castShadow = true;
                    group.add(wheel);
                }
            }
            
            // Windows
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x88CCFF,
                roughness: 0.1,
                transparent: true,
                opacity: 0.7,
            });
            
            // Windshield
            const windshieldGeometry = new THREE.PlaneGeometry(1.8, 0.8);
            const windshield = new THREE.Mesh(windshieldGeometry, windowMaterial);
            windshield.position.set(0.5, 1.7, 0);
            windshield.rotation.set(Math.PI / 4, Math.PI, 0);
            group.add(windshield);
            
            // Headlights
            for (let i = -1; i <= 1; i += 2) {
                const headlightGeometry = new THREE.CircleGeometry(0.2, 16);
                const headlightMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFFFFAA,
                    emissive: 0xFFFF99,
                    emissiveIntensity: 0.5,
                });
                const headlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
                headlight.position.set(2, 0.8, i * 0.8);
                headlight.rotation.y = Math.PI / 2;
                group.add(headlight);
                
                const tailLightGeometry = new THREE.CircleGeometry(0.15, 16);
                const tailLightMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFF0000,
                    emissive: 0xFF0000,
                    emissiveIntensity: 0.5,
                });
                const tailLight = new THREE.Mesh(tailLightGeometry, tailLightMaterial);
                tailLight.position.set(-2, 0.8, i * 0.8);
                tailLight.rotation.y = -Math.PI / 2;
                group.add(tailLight);
            }
            
            return group;
        }

        // Create city blocks and streets
        function createCity() {
            const city = new THREE.Group();
            
            // Create blocks with buildings
            for (let x = 0; x < NUM_BLOCKS; x++) {
                for (let z = 0; z < NUM_BLOCKS; z++) {
                    const blockX = x * (BLOCK_SIZE + STREET_WIDTH) - CITY_SIZE / 2 + BLOCK_SIZE / 2;
                    const blockZ = z * (BLOCK_SIZE + STREET_WIDTH) - CITY_SIZE / 2 + BLOCK_SIZE / 2;
                    
                    const blockType = Math.random();
                    
                    if (blockType < 0.2) { // Downtown with skyscrapers
                        const numBuildings = 1 + Math.floor(Math.random() * 2);
                        for (let i = 0; i < numBuildings; i++) {
                            const buildingWidth = 20 + Math.random() * 10;
                            const buildingDepth = 20 + Math.random() * 10;
                            const buildingHeight = 60 + Math.random() * 80;
                            
                            const offsetX = (Math.random() - 0.5) * (BLOCK_SIZE - buildingWidth);
                            const offsetZ = (Math.random() - 0.5) * (BLOCK_SIZE - buildingDepth);
                            
                            const building = createBuilding(
                                buildingWidth,
                                buildingHeight,
                                buildingDepth,
                                blockX + offsetX,
                                blockZ + offsetZ,
                                'skyscraper'
                            );
                            city.add(building);
                        }
                    } else if (blockType < 0.6) { // Residential with apartment buildings
                        const numBuildings = 2 + Math.floor(Math.random() * 3);
                        for (let i = 0; i < numBuildings; i++) {
                            const buildingWidth = 12 + Math.random() * 8;
                            const buildingDepth = 12 + Math.random() * 8;
                            const buildingHeight = 15 + Math.random() * 25;
                            
                            const offsetX = (Math.random() - 0.5) * (BLOCK_SIZE - buildingWidth);
                            const offsetZ = (Math.random() - 0.5) * (BLOCK_SIZE - buildingDepth);
                            
                            const building = createBuilding(
                                buildingWidth,
                                buildingHeight,
                                buildingDepth,
                                blockX + offsetX,
                                blockZ + offsetZ,
                                'apartment'
                            );
                            city.add(building);
                        }
                    } else { // Commercial with shops
                        const numBuildings = 3 + Math.floor(Math.random() * 4);
                        for (let i = 0; i < numBuildings; i++) {
                            const buildingWidth = 8 + Math.random() * 6;
                            const buildingDepth = 10 + Math.random() * 8;
                            const buildingHeight = 5 + Math.random() * 10;
                            
                            const offsetX = (Math.random() - 0.5) * (BLOCK_SIZE - buildingWidth);
                            const offsetZ = (Math.random() - 0.5) * (BLOCK_SIZE - buildingDepth);
                            
                            const building = createBuilding(
                                buildingWidth,
                                buildingHeight,
                                buildingDepth,
                                blockX + offsetX,
                                blockZ + offsetZ,
                                'shop'
                            );
                            city.add(building);
                        }
                    }
                    
                    // Add street elements around the block
                    if (Math.random() > 0.3) {
                        for (let i = 0; i < 2 + Math.floor(Math.random() * 3); i++) {
                            const offsetX = (Math.random() - 0.5) * BLOCK_SIZE;
                            const offsetZ = (Math.random() - 0.5) * BLOCK_SIZE;
                            
                            if (Math.random() > 0.7) {
                                const tree = createTree(blockX + offsetX, blockZ + offsetZ);
                                city.add(tree);
                            }
                        }
                    }
                }
            }
            
            // Create street elements
            const streetElements = [];
            for (let x = 0; x <= NUM_BLOCKS; x++) {
                for (let z = 0; z <= NUM_BLOCKS; z++) {
                    const streetX = x * (BLOCK_SIZE + STREET_WIDTH) - CITY_SIZE / 2;
                    const streetZ = z * (BLOCK_SIZE + STREET_WIDTH) - CITY_SIZE / 2;
                    
                    // Lampposts at corners
                    if (x < NUM_BLOCKS && z < NUM_BLOCKS) {
                        const lampPost = createLampPost(streetX + STREET_WIDTH / 2, streetZ + STREET_WIDTH / 2);
                        streetElements.push(lampPost);
                        city.add(lampPost);
                    }
                    
                    // Traffic lights at intersections
                    if (x < NUM_BLOCKS && z < NUM_BLOCKS && Math.random() > 0.3) {
                        const trafficLight1 = createTrafficLight(streetX + STREET_WIDTH / 2 - 5, streetZ - 5, Math.PI / 2);
                        const trafficLight2 = createTrafficLight(streetX - 5, streetZ + STREET_WIDTH / 2 - 5, 0);
                        streetElements.push(trafficLight1, trafficLight2);
                        city.add(trafficLight1, trafficLight2);
                    }
                    
                    // Benches along streets
                    if (Math.random() > 0.7) {
                        if (x < NUM_BLOCKS) {
                            const bench1 = createBench(
                                streetX + STREET_WIDTH / 2,
                                streetZ + (Math.random() * BLOCK_SIZE - BLOCK_SIZE / 2),
                                Math.PI / 2
                            );
                            streetElements.push(bench1);
                            city.add(bench1);
                        }
                        
                        if (z < NUM_BLOCKS) {
                            const bench2 = createBench(
                                streetX + (Math.random() * BLOCK_SIZE - BLOCK_SIZE / 2),
                                streetZ + STREET_WIDTH / 2,
                                0
                            );
                            streetElements.push(bench2);
                            city.add(bench2);
                        }
                    }
                }
            }
            
            return { city, streetElements };
        }

        // Create pedestrians
        const pedestrians = [];
        for (let i = 0; i < 50; i++) {
            const pedestrian = createPedestrian();
            
            const x = (Math.random() - 0.5) * (CITY_SIZE - 20);
            const z = (Math.random() - 0.5) * (CITY_SIZE - 20);
            const y = 0.6;
            
            pedestrian.position.set(x, y, z);
            pedestrian.userData = {
                speed: 0.05 + Math.random() * 0.05,
                direction: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(),
                timeSinceDirectionChange: 0,
                directionChangeInterval: 3 + Math.random() * 5,
            };
            
            pedestrians.push(pedestrian);
            scene.add(pedestrian);
        }

        // Create cars
        const cars = [];
        for (let i = 0; i < 30; i++) {
            const car = createCar();
            
            // Position car on a street
            let x, z, direction;
            if (Math.random() > 0.5) {
                // Horizontal street
                const streetIndex = Math.floor(Math.random() * (NUM_BLOCKS + 1));
                z = streetIndex * (BLOCK_SIZE + STREET_WIDTH) - CITY_SIZE / 2 + STREET_WIDTH / 2;
                x = (Math.random() - 0.5) * CITY_SIZE;
                direction = Math.random() > 0.5 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(-1, 0, 0);
                car.rotation.y = direction.x < 0 ? Math.PI : 0;
            } else {
                // Vertical street
                const streetIndex = Math.floor(Math.random() * (NUM_BLOCKS + 1));
                x = streetIndex * (BLOCK_SIZE + STREET_WIDTH) - CITY_SIZE / 2 + STREET_WIDTH / 2;
                z = (Math.random() - 0.5) * CITY_SIZE;
                direction = Math.random() > 0.5 ? new THREE.Vector3(0, 0, 1) : new THREE.Vector3(0, 0, -1);
                car.rotation.y = direction.z < 0 ? Math.PI / 2 : -Math.PI / 2;
            }
            
            car.position.set(x, 0, z);
            car.userData = {
                speed: 0.2 + Math.random() * 0.3,
                direction: direction,
                lane: Math.random() > 0.5 ? 1 : -1, // Right or left lane
            };
            
            cars.push(car);
            scene.add(car);
        }

        // Create city
        const { city, streetElements } = createCity();
        scene.add(city);

        // Day/night cycle control
        const timeSlider = document.getElementById('time-slider');
        const timeDisplay = document.getElementById('time-display');
        let timeOfDay = 12; // Start at noon

        function updateTimeOfDay(newTime) {
            timeOfDay = newTime;
            
            // Update time display
            const hour = Math.floor(timeOfDay);
            const minute = Math.floor((timeOfDay - hour) * 60);
            timeDisplay.textContent = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
            
            // Sun position
            const sunAngle = (timeOfDay / 24) * Math.PI * 2 - Math.PI / 2;
            sunLight.position.x = Math.cos(sunAngle) * 100;
            sunLight.position.y = Math.sin(sunAngle) * 100;
            sunLight.position.z = 0;
            
            // Moon position (opposite to sun)
            moonLight.position.x = -Math.cos(sunAngle) * 100;
            moonLight.position.y = -Math.sin(sunAngle) * 100;
            moonLight.position.z = 0;
            
            // Adjust light intensities based on time of day
            const isDaytime = timeOfDay > 6 && timeOfDay < 18;
            
            if (isDaytime) {
                const noonFactor = 1 - Math.abs(timeOfDay - 12) / 6; // 0 at dawn/dusk, 1 at noon
                sunLight.intensity = 1 + noonFactor;
                moonLight.intensity = 0;
                ambientLight.intensity = 0.5 + noonFactor * 0.5;
                
                // Sky color (bluer at noon, more orange at dawn/dusk)
                const skyHue = 0.55 + noonFactor * 0.05; // 0.55-0.6 (blue)
                const skySat = 0.7 - noonFactor * 0.2; // 0.5-0.7
                const skyLightness = 0.7 + noonFactor * 0.1; // 0.7-0.8
                
                sky.material.color.setHSL(skyHue, skySat, skyLightness);
            } else {
                const midnightFactor = 1 - Math.abs(timeOfDay - 0) / 6; // 0 at dawn/dusk, 1 at midnight
                // Adjust for midnight wrap around
                const adjustedMidnightFactor = (timeOfDay > 18) ? 
                    1 - Math.abs(timeOfDay - 24) / 6 : 
                    1 - Math.abs(timeOfDay) / 6;
                
                sunLight.intensity = 0;
                moonLight.intensity = 0.3 + adjustedMidnightFactor * 0.2;
                ambientLight.intensity = 0.1 + adjustedMidnightFactor * 0.1;
                
                // Night sky (dark blue)
                const nightHue = 0.7 + adjustedMidnightFactor * 0.05; // 0.7-0.75 (darker blue)
                const nightSat = 0.8;
                const nightLightness = 0.1 + adjustedMidnightFactor * 0.05; // 0.1-0.15
                
                sky.material.color.setHSL(nightHue, nightSat, nightLightness);
            }
            
            // Turn on streetlights at night
            streetElements.forEach(element => {
                const lights = element.children.filter(child => child instanceof THREE.PointLight);
                lights.forEach(light => {
                    if (isDaytime) {
                        light.intensity = 0;
                    } else {
                        light.intensity = 1;
                    }
                });
                
                // Update lamp emissive properties
                const lamps = element.children.filter(child => 
                    child instanceof THREE.Mesh && 
                    child.material && 
                    child.material.emissive
                );
                
                lamps.forEach(lamp => {
                    if (isDaytime) {
                        lamp.material.emissiveIntensity = 0.1;
                    } else {
                        lamp.material.emissiveIntensity = 1;
                    }
                });
            });
            
            // Turn on car headlights and emissive building windows at night
            cars.forEach(car => {
                const lights = car.children.filter(child => 
                    child instanceof THREE.Mesh && 
                    child.material && 
                    child.material.emissive
                );
                
                lights.forEach(light => {
                    if (isDaytime) {
                        light.material.emissiveIntensity = 0.1;
                    } else {
                        light.material.emissiveIntensity = 1;
                    }
                });
            });
            
            // Update building window emissive properties
            city.traverse(object => {
                if (object instanceof THREE.Mesh && 
                    object.material && 
                    object.material.emissive) {
                    
                    if (isDaytime) {
                        object.material.emissiveIntensity = 0.1;
                    } else {
                        // Random window lighting patterns at night
                        if (Math.random() > 0.7) {
                            object.material.emissiveIntensity = 0.5 + Math.random() * 0.5;
                        } else {
                            object.material.emissiveIntensity = 0.1;
                        }
                    }
                }
            });
        }

        timeSlider.addEventListener('input', () => {
            updateTimeOfDay(parseFloat(timeSlider.value));
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = 0.016; // Approximate for 60fps
            
            // Update pedestrians
            pedestrians.forEach(pedestrian => {
                const data = pedestrian.userData;
                
                // Change direction occasionally
                data.timeSinceDirectionChange += delta;
                if (data.timeSinceDirectionChange > data.directionChangeInterval) {
                    data.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                    data.timeSinceDirectionChange = 0;
                    data.directionChangeInterval = 3 + Math.random() * 5;
                    
                    // Turn to face the direction of movement
                    pedestrian.rotation.y = Math.atan2(data.direction.x, data.direction.z);
                }
                
                // Move pedestrian
                pedestrian.position.x += data.direction.x * data.speed;
                pedestrian.position.z += data.direction.z * data.speed;
                
                // Keep within city bounds
                if (pedestrian.position.x > CITY_SIZE / 2 - 10) {
                    pedestrian.position.x = CITY_SIZE / 2 - 10;
                    data.direction.x *= -1;
                }
                if (pedestrian.position.x < -CITY_SIZE / 2 + 10) {
                    pedestrian.position.x = -CITY_SIZE / 2 + 10;
                    data.direction.x *= -1;
                }
                if (pedestrian.position.z > CITY_SIZE / 2 - 10) {
                    pedestrian.position.z = CITY_SIZE / 2 - 10;
                    data.direction.z *= -1;
                }
                if (pedestrian.position.z < -CITY_SIZE / 2 + 10) {
                    pedestrian.position.z = -CITY_SIZE / 2 + 10;
                    data.direction.z *= -1;
                }
                
                // Turn to face the direction of movement
                pedestrian.rotation.y = Math.atan2(data.direction.x, data.direction.z);
            });
            
            // Update cars
            cars.forEach(car => {
                const data = car.userData;
                
                // Move car
                car.position.x += data.direction.x * data.speed;
                car.position.z += data.direction.z * data.speed;
                
                // Keep cars in lanes
                if (data.direction.x !== 0) { // Car moving along X axis
                    const laneOffset = data.lane * STREET_WIDTH / 4;
                    car.position.z = Math.round(car.position.z / (BLOCK_SIZE + STREET_WIDTH)) * (BLOCK_SIZE + STREET_WIDTH) + STREET_WIDTH / 2 + laneOffset;
                } else { // Car moving along Z axis
                    const laneOffset = data.lane * STREET_WIDTH / 4;
                    car.position.x = Math.round(car.position.x / (BLOCK_SIZE + STREET_WIDTH)) * (BLOCK_SIZE + STREET_WIDTH) + STREET_WIDTH / 2 + laneOffset;
                }
                
                // Wrap around when reaching city bounds
                if (car.position.x > CITY_SIZE / 2 + 20) {
                    car.position.x = -CITY_SIZE / 2 - 20;
                }
                if (car.position.x < -CITY_SIZE / 2 - 20) {
                    car.position.x = CITY_SIZE / 2 + 20;
                }
                if (car.position.z > CITY_SIZE / 2 + 20) {
                    car.position.z = -CITY_SIZE / 2 - 20;
                }
                if (car.position.z < -CITY_SIZE / 2 - 20) {
                    car.position.z = CITY_SIZE / 2 + 20;
                }
            });
            
            // Update controls
            controls.update();
            
            // Slowly advance time of day
            timeOfDay = (timeOfDay + 0.001) % 24;
            timeSlider.value = timeOfDay;
            updateTimeOfDay(timeOfDay);
            
            renderer.render(scene, camera);
        }

        // Resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize, false);
        
        // Initial time update and start animation
        updateTimeOfDay(timeOfDay);
        animate();
    </script>
</body>
</html>
