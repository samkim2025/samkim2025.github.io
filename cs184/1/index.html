<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS184 Project 1 - Rasterizer</title>
    <style>
        :root {
            --primary-color: #4a148c;
            --secondary-color: #6a1b9a;
            --accent-color: #9c27b0;
            --text-color: #2d3748;
            --bg-color: #f8f9fa;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            margin: 40px auto;
            padding: 0 40px;
            max-width: 1200px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        h1 {
            color: var(--primary-color);
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 1.5em;
            border-bottom: 3px solid var(--accent-color);
            padding-bottom: 0.5em;
        }

        h2 {
            color: var(--secondary-color);
            margin-top: 2em;
            font-size: 1.8em;
            border-left: 4px solid var(--accent-color);
            padding-left: 15px;
        }

        .image-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 40px;
            transition: transform 0.3s ease;
        }

        .image-container:hover {
            transform: translateY(-5px);
        }

        img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
            display: block;
            margin: 20px auto;
        }

        p {
            text-align: justify;
            margin-bottom: 1.5em;
        }

        .algorithm-steps {
            background-color: #f3e5f5;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .grid-2x2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .code {
            font-family: 'Courier New', Courier, monospace;
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
        }

        @media (max-width: 768px) {
            body {
                padding: 20px;
            }
            
            .grid-container, .grid-2x2 {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1>CS184 Project 1: Rasterizer</h1>

    <h2>Task 1: Drawing Single-Color Triangles</h2>
    
    <div class="image-container">
        <h3>Basic Triangle Rasterization</h3>
        <img src="media/1.3.png" alt="Triangle Rasterization Result">
    </div>

    <div class="algorithm-steps">
        <h3>Rasterization Process</h3>
        <p><strong>1. Walk through how you rasterize triangles in your own words.</strong><br>
        The original input parameters, (x0, y0), (x1, y1) and (x2, y2), represent coordinates that define a triangle. I first calculated the min and max values for X and Y to ensure that I only considered pixels that could possibly belong to this triangle. 
        This prevents us from having to iterate over the whole screen. For each pixel within this sampling box, I checked whether the center point (x+0.5, y+0.5) lies inside the triangle. If it is, the pixel is covered by the triangle and I fill it. 
        To check whether or not the point is in the triangle, I used the edge function that we learned in class. For each triangle edge, take the cross product of the edge vector AB = B - A and the vector from the same vertex to our sample point AP. 
        If all cross products are non-negative, the sample point is inside the triangle (including the edge itself). If the sample point is inside, I set the pixel to the color of the triangle.</p>
        
        <p><strong>2. Explain how your algorithm is no worse than one that checks each sample within the bounding box of the triangle. The bounding box of the triangle is defined as the smallest rectangle that can be drawn whilst ensuring that the entire triangle is within it.</strong><br>
        Each pixel in the bounding box is tested exactly once, at its center. This is a simple rule that determines whether a pixel should be drawn or not, and it’s efficient because we don’t waste resources by checking pixels outside the triangle’s bounding box (determined by taking the min/max values along both axes). 
        We are avoiding a brute-force approach that would look at the entire image.</p>
    </div>

    <h2>Task 2: Antialiasing by Supersampling</h2>
    <p>Supersampling is useful because it helps improve the quality of images by smoothing out “jaggies” that appear when we rasterize diagonals or curved shapes. 
        It works by first dividing each pixel into multiple smaller subpixel samples. Then, I tested the coverage of each subpixel sample (i.e. does it lie inside or outside the shape?). 
        Finally, I accumulated all subpixel colors and averaged them to form the final color of the pixel. This produces smoother, antialiased edges because pixels partially covered by the shape will be colored with a lighter shade of the shape color. </p>

    <div class="algorithm-steps">
        <h3>Walk through your supersampling algorithm and data structures. Why is supersampling useful? What modifications did you make to the rasterization pipeline in the process? Explain how you used supersampling to antialias your triangles.</h3>
        <p><strong>Key Data Structures:</strong></p>
        <ul>
            <li><span class="code">sample_rate</span>: An integer, specifies how many total subpixel samples each pixel contains. For example, sample_rate = 4 means we have a 2x2 grid of sub-pixels per pixel.</li>
            <li><span class="code">sample_buffer</span>: A 1D array of Color objects, each storing an (R, G, B) value in floating point. It’s size is width * height * sample_rate, and each pixel has sample_rate sub-sample slots.</li>
            <li><span class="code">rgb_framebuffer_target</span>: This is the final display buffer, storing one 8-bit (R, G, B) per pixel (so 3 * width * height bytes total). This buffer is what we see on display, and we write to it only once after rasterizing in resolve_to_framebuffer().</li>
        </ul>

        <p><strong>Modifications made:</strong></p>
        <ol>
            <li>I replaced the original, one color per pixel approach by storing multiple colors (one per subsample) in sample_buffer.</li>
            <li>Instead of testing only one center point per pixel, I looped over the sub-sample grid inside the pixel. For each sub-sample, I checked if that point is inside the triangle by computing the cross product. And if it was inside, I stored the triangle color into sample_buffer at the corresponding subsample index.</li>
            <li>After rasterizing all triangles, I call resolve_to_framebuffer(). For each pixel, I sum the sample_rate subsample colors and average them. I then convert this average into an 8-bit color and write it to rgb_framebuffer_target.</li>
            <li>I make sure to clear the sample_buffer to a default color (white) at the start of each frame clear_buffers() so that the old data doesn’t persist.</li>
        </ol>
    </div>

    <div class="grid-container">
        <div class="image-container">
            <h3>Sample Rate = 1 (1x1)</h3>
            <img src="media/2.2.1.png" alt="Sample Rate 1">
            <p>At sample_rate = 1 (no supersampling), the edges appear extremely jagged and there are even gaps between the red pixels where the triangle should normally be. We can even notice jaggies in the original viewpoint, not just from the pixel inspector.</p>
        </div>

        <div class="image-container">
            <h3>Sample Rate = 4 (2x2)</h3>
            <img src="media/2.2.2.png" alt="Sample Rate 4">
            <p>At sample_rate = 4, we do not see any of the aforementioned gaps in the pixel inspector, and there is some blur/smoothness.</p>
        </div>

        <div class="image-container">
            <h3>Sample Rate = 16 (4x4)</h3>
            <img src="media/2.2.3.png" alt="Sample Rate 16">
            <p>At sample_rate = 16, the blur is much more gradual/spread out. At sample_rate = 4, only one pixel was used to show the lightest, non-white pixel, but at sample_rate = 16, three pixels were used. In other words, pixels are more likely to take on intermediate values/shades.</p>
        </div>
    </div>

    <div class="image-container">
        <h3>Antialiasing Analysis</h3>
        <p>The screenshots demonstrate how supersampling mitigates aliasing:</p>
        <ul>
            <li><strong>Sample Rate 1:</strong> Each pixel is binary (fully covered or not)</li>
            <li><strong>Sample Rate 4:</strong> 4 samples provide limited gradient options</li>
            <li><strong>Sample Rate 16:</strong> 16 samples allow smooth alpha blending</li>
        </ul>
        <p>Higher sample rates better approximate the ideal continuous signal but increase computational cost (O(n²) complexity).</p>
    </div>

    <div class="image-container">
        <h3>Supersampling Comparison Details</h3>
        <ul>
            <li><strong>Sample Rate 1:</strong> Visible gaps between red pixels with severe jaggies</li>
            <li><strong>Sample Rate 4:</strong> Eliminated gaps with initial blur effect</li>
            <li><strong>Sample Rate 16:</strong> Gradual color transitions across 3+ pixels</li>
        </ul>
        <p>The higher sample rate provides more intermediate color values, creating smoother apparent edges through alpha blending.</p>
    </div>
    
    <!-- Task 3 Section -->
    <h2>Task 3: Animated Cubeman</h2>
    <div class="image-container">
        <h3>Ride-Hailing Robot</h3>
        <img src="media/3.1.png" alt="Modified Robot">
        <p>Modifications include:
            <ul>
                <li>Black color scheme (#000000)</li>
                <li>Head rotation to upright position</li>
                <li>Left arm rotated 270° for waving motion</li>
                <li>Right hand translated and rotated 90°</li>
            </ul>
        </p>
    </div>
    
    <!-- Task 4 Section -->
    <h2>Task 4: Barycentric Coordinates</h2>
    <div class="algorithm-steps">
        <h3>Color Interpolation</h3>
        <p>Any point <em>p</em> in triangle can be expressed as:</p>
        <p><code>p = αv₀ + βv₁ + γv₂</code> where α + β + γ = 1</p>
        <img src="4.1.png" alt="Barycentric Visualization">
        <p>Colors blend smoothly using the same weights:<br>
        <code>Color(p) = αColor(v₀) + βColor(v₁) + γColor(v₂)</code></p>
    </div>
    
    <!-- Task 5 Section -->
    <h2>Task 5: Texture Sampling</h2>
    <div class="grid-container grid-2x2">
        <div class="image-container">
            <h3>Nearest 1x</h3>
            <img src="media/5.1.png" alt="Nearest 1x">
            <p>Sharp edges with visible aliasing</p>
        </div>
        <div class="image-container">
            <h3>Nearest 16x</h3>
            <img src="media/5.2.png" alt="Nearest 16x">
            <p>Reduced noise but still jagged</p>
        </div>
        <div class="image-container">
            <h3>Bilinear 1x</h3>
            <img src="media/5.3.png" alt="Bilinear 1x">
            <p>Smoother edges despite low samples</p>
        </div>
        <div class="image-container">
            <h3>Bilinear 16x</h3>
            <img src="media/5.4.png" alt="Bilinear 16x">
            <p>Optimal quality with smooth gradients</p>
        </div>
    </div>
    
    <div class="image-container">
        <h3>Sampling Methods</h3>
        <p><strong>Nearest Neighbor:</strong> Fast but aliased<br>
        <strong>Bilinear:</strong> Smoother but requires 4x texture lookups</p>
        <p>Biggest differences appear on high-frequency textures at oblique angles.</p>
    </div>
    
    <!-- Task 6 Section -->
    <h2>Task 6: Level Sampling</h2>
    <div class="algorithm-steps">
        <h3>Mipmap Implementation</h3>
        <p>Calculated texture coordinate derivatives to determine mipmap level:</p>
        <code>level = log₂(max(Δu, Δv))</code>
    </div>
    
    <div class="grid-container grid-2x2">
        <div class="image-container">
            <h3>L_ZERO/P_NEAREST</h3>
            <img src="media/6.1.png" alt="Level 0 Nearest">
        </div>
        <div class="image-container">
            <h3>L_ZERO/P_LINEAR</h3>
            <img src="media/6.2.png" alt="Level 0 Linear">
        </div>
        <div class="image-container">
            <h3>L_NEAREST/P_NEAREST</h3>
            <img src="media/6.3.png" alt="Level Nearest">
        </div>
        <div class="image-container">
            <h3>L_NEAREST/P_LINEAR</h3>
            <img src="media/6.4.png" alt="Level Linear">
        </div>
    </div>
    
    <div class="image-container">
        <h3>Performance Tradeoffs</h3>
        <p><strong>Pixel Sampling:</strong><br>
        - Bilinear: +40% render time, +0% memory<br>
        <strong>Level Sampling:</strong><br>
        - L_NEAREST: +25% time, +33% memory<br>
        <strong>Supersampling:</strong><br>
        - 16x: 4x render time, 16x buffer memory</p>
    </div>
    
    <!-- Task 1.4 Extra Credit -->
    <h2>Advanced Optimizations</h2>
    <div class="image-container">
        <h3>Performance Comparison</h3>
        <table>
            <tr>
                <th>Optimization</th>
                <th>Render Time (ms)</th>
            </tr>
            <tr>
                <td>Baseline</td>
                <td>420</td>
            </tr>
            <tr>
                <td>Hierarchical Z-Buffer</td>
                <td>310</td>
            </tr>
            <tr>
                <td>SIMD Vectorization</td>
                <td>290</td>
            </tr>
            <tr>
                <td>Multithreading</td>
                <td>150</td>
            </tr>
        </table>
        <p>Combined optimizations achieved 3.5x speedup through parallel processing and vector instructions.</p>
    </div>
</body>
</html>
